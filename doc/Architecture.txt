Introduction to the EGTP Architecture:


I. Overall Design

A. Nonces and References

The idea is that data is transmitted between EGTP nodes in the form of messages.
Each message contains a unique (randomly generated) nonce which guarantees that 
it is unique among all messages ever transmitted universally through all 
history.  When you receive a message from another EGTP node, and you wish to 
*reply* to that message so that the sender will get your reply, and will know 
that it is a reply to that particular message that she sent, you include a hash 
of the original message in your reply (this hash is called the "reference" -- it 
refers to the original message).  This allows the sender to know with certainty 
that your message is a reply to that particular query of his.  This is how the 
sender's EGTP library associated queries with replies, and it also provides 
assurance that the messages received as a reply isn't a replay attack or some 
other active attack.

Note that this design does not provide protection against active attacks for the 
node that receives the initial query, only for the node that sent the initial 
query and awaits the reply.  (The node receiving the initial queries could 
protect themselves against replay attacks by remembering the hash of each 
message they have ever received, but this would require an unbounded amount of 
storage.)

Fixing this problem turns out to be surprisingly subtle, at least judging by how 
long it has taken me, Zooko, to come up with a complete solution.  That solution 
will form the basis of EGTP v2 design.

This problem is documented as a security bug:
http://sourceforge.net/tracker/index.php?func=detail&aid=548075&group_id=44377&atid=439350


B. Timeouts

Each query message that has been sent is associated with one kind of timeout, a 
"hard" timeout.  This is the interval after which the sender will free up all storage associated


II. General Implementation Stuff

A. nodeIds 

nodeIds (formerly known as "broker Ids") are universally unique 20-byte 
identifiers.  They are formed by taking the SHA1 hash of the public key of 
the Node, along with some extra fixed strings for cryptographic/engineering 
reasons.  When you are talking about the nodeId of a peer (as opposed to the 
node Id of yourself), you call it a "peerId" (formerly known as 
"counterparty Id").

B. Relay

Relay is an important feature of EGTP, but it is best understood as a layer on 
*top* of the TCP part of EGTP.  Ignore relay on your first pass through, and 
then once you understand EGTP-over-TCP you can understand relay as follows:

To relay a message M to a recipient B through a relayer R, you simply make a 
message M2, which says "recipient: B, message: M" and you send M2 to R.

Now that you understand that much, you can look at CommStrat.Relay (implements 
the sending of relayed messages), RelayServerHandlers (implements the relay 
service) (whoops -- that file is missing from egtp -- find it in mnet), and 
RelayListener (implements receiving relayed messages).

C. Threading and Event Queue

Almost everything has to be invoked from the DoQ.  The exceptions are that 
TCPConnection interacts with the low-level sockets via a separate thread 
called "the asyncore thread".  There are liberal precondition assertions to 
help you notice right away if you make a call from the wrong thread.

* Can we get an example put in here. (I know, I should understand the DoQ by
now, but it still confuses me why we have a seperate thread to schedule events.
Maybe I just need a description of the DoQ and its purpose for those of us who
are not used to event driven programing.)

D. Throttling and Other Delays

If a TCPConnection can't send a message, because the connection isn't open 
yet, or the outgoing buffer is full, or something, then it just holds the 
message in its own buffer and tries again when the asyncore notifies it to 
proceed.  Throttling simply artificially enforces this situation: when 
throttled, the TCPConnection will not try to send any data until unthrottled.  


III. Classes

A. CommStrat

There is a class named "CommStrat".  It is a generalization of an address.  
Subclasses of it include CommStrat.TCP (which handles both the case that you 
have an IP address and port num, and the case that you have an open TCP 
socket), CommStrat.Relay (which means that messages get sent via a relay 
server), and CommStrat.Crypto (which means that messages get encrypted and 
then passed on to a "lower-level strategy" for actual delivery).

I now believe that it was a mistake to make CommStrat.Crypto have the same 
role as the actual transport strats, but oh well.

Strategy objects should have a send() method. 

B. TCPCommsHandler

TCPCommsHandler is mostly responsible for managing when to open and close 
connections.  It tries to be very clever about keeping connections open if it 
expects to use them again.  It's complicated.  We don't know for sure that the 
behavior is good enough to justify the performance, but on the other hand it 
is the product of three years of evolution, and it works, so please don't 
break it unless you need to.

C. TCPConnection

TCPConnection is responsible for: a) twiddling the socket objects and managing 
buffers of incoming and outgoing data.  Closing the connection.  This is the 
part that most closely touches Asyncore.  b) prepending lengths to outgoing 
messages and "chunking" incoming streams into known-length messages.  Also 
letting the higher-level code know if an outgoing message couldn't be sent 
(known as "fast fail").  c) making calls to a "Throttler" object to enable 
bandwidth throttling.

Questions:
How do we know if a message was sent successfully or not? Do we get ack messages?
What if a relay server is involved?


Ok, Explain Lookup vs. Discovery again.

Lookup is verifiable while Discovery is not?

Does this mean that in a DHT a lookup might find which node should have a peice of data? While a discovery might be which IP address a node was reachable at? (Since you cant prove the later from its key.) 